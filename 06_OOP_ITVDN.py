##########################################################################################################################
###  SIMPLE CLASS  ###

# Объявление пустого класса MyClass
class MyClass:
    pass

# Создание экземпляра класса
obj = MyClass()

# Вывод типа obj
print(type(obj))





##########################################################################################################################
###  CLASSES AS OBJECTS  ###

# В Python всё является объектами, в том числе
# и сами классы

# Объявление пустого класса MyClass
class MyClass:
    pass

# Создание экземпляра класса
obj = MyClass()

# Объект obj -- это экземпляр класса MyClass, то есть он имеет тип MyClass
print(type(obj))                    # <class '__main__.MyClass'>

# MyClass -- это класс, но также он является и объектом, экземпляром метакласса type, являющегося абстракцией понятия типа данных
print(type(MyClass))                # <class 'type'>

# Соответственно, с классами работать как с объектами, например, копировать
AnotherClass = MyClass
print(type(AnotherClass))           # <class 'type'>

# Как видим, теперь AnotherClass -- это то же самое, что и MyClass, и obj является и экземпляром класса AnotherClass
print(isinstance(obj, AnotherClass))  # True





##########################################################################################################################
###  CLASSES ATTRIBUTES  ###

# Все члены класса в терминологии Python называются атрибутами

# Объявление класса MyClass с двумя атрибутами int_field и str_field. Атрибуты класса, являющиеся переменными, примерно соответствуют статическим полям класса в других языках программирования
class MyClass:
    int_field = 8
    str_field = 'string'


# Обращение к атрибутам класса
print(MyClass.int_field)            # 8
print(MyClass.str_field)            # string

# Создание двух экземпляров класса
object1 = MyClass()
object2 = MyClass()

# Обращение к атрибутам класса через его экземпляры
print(object1.int_field)            # 8
print(object2.str_field)            # string

# Все вышеперечисленные обращения к атрибутам на самом деле относятся ко двум одним и тем же переменным

# Изменение значения атрибута класса
MyClass.int_field = 10
print(MyClass.int_field)            # 10
print(object1.int_field)            # 10
print(object2.int_field)            # 10

# Однако, аналогично глобальным и локальным переменным, присвоение значение атрибуту объекта не изменяет значение атрибута класса, а ведёт к созданию атрибута данных (нестатического поля)
object1.str_field = 'another string'
print(MyClass.str_field)            # string
print(object1.str_field)            # another string
print(object2.str_field)            # string





##########################################################################################################################
###  DATA ATTRIBUTES  ###
# Атрибуты-данные аналогичны полям в терминологии большинства распространённых языков программирования.
# Атрибуты-данные не нужно описывать: как и переменные, они создаются в момент первого присваивания.

# Класс, описывающий человека
class Person:
    pass

# Создание экземпляров класса
alex = Person()
alex.name = 'Alex'
alex.age = 18

john = Person()
john.name = 'John'
john.age = 20

# Атрибуты-данные относятся только к отдельным экземплярам класса и никак не влияют на значения соответствующих атрибутов-данных других экземпляров
print(alex.name, 'is', alex.age)
print(john.name, 'is', john.age)





##########################################################################################################################
###  METHODS  ###
# Атрибутами класса могут быть и функции

# Класс, описывающий человека
class Person:
    # Первый аргумент, который указывает на текущий экземпляр класса, принято называть self
    def print_info(self):
        print(self.name, 'is', self.age)

# Создание экземпляров класса
alex = Person()
alex.name = 'Alex'
alex.age = 18

john = Person()
john.name = 'John'
john.age = 20

# Проверим, чем является атрибут print_info класса Person
print(Person.print_info)                        # <function Person.print_info at 0x00000148C1B88220>
print(type(Person.print_info))                  # функция (<class 'function'>)

# Вызовем её для объектов alex и john
Person.print_info(alex)                        # Alex is 18
Person.print_info(john)                        # John is 20

# Метод -- это функция, привязанная к объекту. Все атрибуты класса, являющиеся функциями, описывают соответствующие методы экземпляров
# данного класса.

print(alex.print_info)                            # <bound method Person.print_info of <__main__.Person object at 0x0000017351116A50>> (привязанный метод который лежит уже по другому адресу)
print(type(alex.print_info))                      # метод (<class 'method'>)

# Вызов метода print_info
alex.print_info()                                 # Alex is 18
john.print_info()                                 # John is 20





##########################################################################################################################
###  __init__  ###
# Начальное состояние объекта следует создавать в специальном методе-конструкторе __init__, который вызывается автоматически после создания экземпляра класса
# Его параметры указываются при создании объекта

# Класс, описывающий человека
class Person:
    # Конструктор
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Метод из прошлого примера
    def print_info(self):
        print(self.name, 'is', self.age)


# Создание экземпляров класса
alex = Person('Alex', 18)
john = Person('John', 20)

# Вызов метода print_info
alex.print_info()                # Alex is 18
john.print_info()                # John is 20





##########################################################################################################################
###  __init__  ###




..[end]
